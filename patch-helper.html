<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>启明字库补丁去重小助手</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif; margin: 18px; line-height: 1.55; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .hint { opacity: .8; font-size: 13px; margin: 6px 0 14px; }
    textarea { width: 100%; min-height: 160px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; border-radius: 10px; border: 1px solid #ddd; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin: 10px 0; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ddd; background: #fff; cursor: pointer; }
    button:hover { border-color: #bbb; }
    .ok { color: #0a7; font-weight: 600; }
    .bad { color: #c33; font-weight: 600; }
    pre { white-space: pre-wrap; word-break: break-word; background: #fafafa; border: 1px solid #eee; border-radius: 10px; padding: 10px; font-size: 12px; }
    .pill { display:inline-block; padding:2px 8px; border-radius: 999px; border:1px solid #eee; background:#fafafa; font-size:12px; margin-right:6px;}
  </style>
</head>
<body>
  <h1>启明字库补丁去重小助手 ✨</h1>
  <div class="hint">
    作用：把你“新收集的一坨字”（可能重复）和仓库里的 <span class="pill">qiming_patch.json</span> 合并，自动去重，输出一份干净的新补丁。
    <br/>可粘贴两种格式：<span class="pill">{"chars":{...}}</span> 或者直接 <span class="pill">{"锦":{...},"铎":{...}}</span>
  </div>

  <div class="row">
    <button id="btnLoad">读取仓库现有 qiming_patch.json</button>
    <button id="btnMerge">合并 + 去重</button>
    <button id="btnCopy">复制输出 JSON</button>
    <button id="btnDownload">下载 qiming_patch.json</button>
    <button id="btnClear">清空输入</button>
  </div>

  <div class="hint">
    <span class="pill">现有补丁</span><span id="statusBase" class="bad">未读取</span>
    <span class="pill">待合并条目数</span><span id="statusIncoming">0</span>
    <span class="pill">发现重复键</span><span id="statusDup">0</span>
    <span class="pill">覆盖冲突</span><span id="statusConflict">0</span>
  </div>

  <div class="hint">把 Gemini 输出粘贴到这里（可以一段一段粘）：</div>
  <textarea id="incoming" placeholder='示例：
{
  "chars": {
    "锦": {"stroke":16,"wuxing":"金","mean":"..."},
    "铎": {"stroke":21,"wuxing":"金","mean":"..."}
  }
}
或：
{
  "锦": {"stroke":16,"wuxing":"金","mean":"..."},
  "铎": {"stroke":21,"wuxing":"金","mean":"..."}
}'></textarea>

  <div class="hint">输出（已经去重、按字排序）：</div>
  <pre id="out">（先读取现有补丁，再合并）</pre>

<script>
  const $ = (id) => document.getElementById(id);

  let base = { chars: {} };
  let merged = null;

  function normalize(obj) {
    if (!obj || typeof obj !== 'object') throw new Error('不是对象 JSON');
    if (obj.chars && typeof obj.chars === 'object') return { chars: obj.chars };
    // 兼容直接字典格式
    return { chars: obj };
  }

  function stableStringify(obj) {
    // 按字排序，字段顺序固定
    const keys = Object.keys(obj.chars || {}).sort((a,b)=>a.localeCompare(b,'zh-Hans'));
    const out = { chars: {} };
    for (const k of keys) {
      const v = obj.chars[k] || {};
      out.chars[k] = {
        stroke: Number(v.stroke ?? v.strokes ?? v.bihua ?? v.biHua ?? v.count ?? v.n ?? v['笔画'] ?? v['stroke']),
        wuxing: String(v.wuxing ?? v.wx ?? v['五行'] ?? ''),
        mean: String(v.mean ?? v.desc ?? v['释义'] ?? v['meaning'] ?? '')
      };
      // 去掉 NaN / 空值
      if (!Number.isFinite(out.chars[k].stroke)) delete out.chars[k].stroke;
      if (!out.chars[k].wuxing) delete out.chars[k].wuxing;
      if (!out.chars[k].mean) delete out.chars[k].mean;
    }
    return JSON.stringify(out, null, 2);
  }

  function parseMany(text) {
    text = (text || '').trim();
    if (!text) return [];
    try { return [normalize(JSON.parse(text))]; } catch (e) {}
    // 粗暴分割：以 "}\n{" 作为边界
    const parts = text.split(/}\s*\n\s*{/).map((p,i,arr)=>{
      if (arr.length === 1) return p;
      if (i === 0) return p + '}';
      if (i === arr.length - 1) return '{' + p;
      return '{' + p + '}';
    }).map(s=>s.trim()).filter(Boolean);

    const objs = [];
    for (const p of parts) {
      try { objs.push(normalize(JSON.parse(p))); } catch (e) {}
    }
    return objs;
  }

  function countDupKeys(objs) {
    const seen = new Set();
    let dup = 0;
    for (const o of objs) {
      for (const k of Object.keys(o.chars || {})) {
        if (seen.has(k)) dup++;
        else seen.add(k);
      }
    }
    return dup;
  }

  $('btnLoad').addEventListener('click', async () => {
    try {
      const r = await fetch('./qiming_patch.json', { cache: 'no-store' });
      if (!r.ok) throw new Error('没找到 qiming_patch.json（可能仓库里还没放）');
      const obj = await r.json();
      base = normalize(obj);
      $('statusBase').textContent = '已读取';
      $('statusBase').className = 'ok';
      $('out').textContent = '已读取现有补丁。现在粘贴你的新字，然后点“合并 + 去重”。';
    } catch (e) {
      $('statusBase').textContent = '读取失败';
      $('statusBase').className = 'bad';
      $('out').textContent = '读取失败：' + e.message + '\n\n你可以先把 qiming_patch.json 放到仓库根目录，然后再刷新这个页面。';
    }
  });

  $('btnMerge').addEventListener('click', () => {
    try {
      const text = $('incoming').value;
      const objs = parseMany(text);
      const incoming = { chars: {} };
      for (const o of objs) Object.assign(incoming.chars, o.chars);

      $('statusIncoming').textContent = Object.keys(incoming.chars).length;
      $('statusDup').textContent = countDupKeys(objs);

      // 冲突：同一个字在 base 里存在且字段值不同
      let conflicts = 0;
      merged = { chars: { ...base.chars } };
      for (const [k,v] of Object.entries(incoming.chars)) {
        if (merged.chars[k]) {
          const a = JSON.stringify(merged.chars[k]||{});
          const b = JSON.stringify(v||{});
          if (a !== b) conflicts++;
        }
        merged.chars[k] = v; // 新的覆盖旧的
      }
      $('statusConflict').textContent = conflicts;

      $('out').textContent = stableStringify(merged);
    } catch (e) {
      $('out').textContent = '合并失败：' + e.message + '\n\n小提示：确保粘贴内容是 JSON（用双引号），不要带 // 注释。';
    }
  });

  $('btnCopy').addEventListener('click', async () => {
    try {
      const text = $('out').textContent;
      await navigator.clipboard.writeText(text);
      $('out').textContent = '✅ 已复制到剪贴板。\n\n' + text;
    } catch (e) {
      $('out').textContent = '复制失败：浏览器可能不允许。\n你可以手动全选输出区复制。\n\n' + $('out').textContent;
    }
  });

  $('btnDownload').addEventListener('click', () => {
    const text = $('out').textContent;
    const blob = new Blob([text], { type: 'application/json;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'qiming_patch.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  $('btnClear').addEventListener('click', () => {
    $('incoming').value = '';
    $('statusIncoming').textContent = '0';
    $('statusDup').textContent = '0';
    $('statusConflict').textContent = '0';
  });
</script>
</body>
</html>
